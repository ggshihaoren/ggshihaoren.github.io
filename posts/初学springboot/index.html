<!DOCTYPE html>











<html lang="en-us">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>初学SpringBoot - GG&#39;s blog</title>

  
  
  <meta name="description" content="从后端零基础开始 由于本学期J2EE课程作业需要，我们小组需要前后端分离去学习不同的东西。前端关于HTML,CSS,JSP的内容已经有些许了解了，但是后端部分的知识却是一点都不知道。出于想学习新东西的心态，我便选择开始学习后端部分的知识。
可能是觉得老师教的东西有些许过时了，我们的组长便决定不完全按照老师所教的东西来，而是选择了SpringBoot 和 MyBatis 作为我们的后端选型，数据库也不是MYSQL，而是 MariaDB(我们组长到底是怎么知道这么多东西的真的好厉害必须狠狠夸一波)。
于是便有了后面一些关于SpringBoot的简单学习。
SpringBoot是什么？ 要弄懂SpringBoot是什么或许得先了解Spring应用开发的相关知识。简单来说，它是一种为了解决企业应用程序开发复杂性而创建的开源的框架。框架的主要优势之一就是其分层架构，分层架构允许我们使用哪一种组件，同时为J2EE应用程序开发提供了集成的框架。
而SpringBoot呢？它也是一种框架。它被设计出来的目的便是为了简化Spring应用的创建，运行，调试，部署等功能。它打包了许多本来需要我们自己去配置的功能，按照人们的使用习惯解决了依赖问题，这样便可以降低开发人员对于框架的关注点，可以把更多的精力放在自己的业务代码上。总的来说，其目的就是为了Java Web的开发进行&quot;简化&quot;和&quot;加快速度&quot;，简化开发过程中引入或启动相关Spring功能的配置。使用SpringBoot我们就可以不用或者只需很少的Spring配置就可以让企业项快速运行起来。
简单尝试 打开IDEA，Generator选择的是Spring Initializr，取名默认为demo，再选择了Gradle作为此次的项目结构便开始了我的第一次尝试(网上大部分的教程好像都是使用了MAVEN，但是据说是使用Gradle的人越来越多了，便试着使用了它)。这里要注意在第二步中需要勾选Spring Web才能顺利进行这个框架的构建~
之后便是愉快的贴代码环节了。通过src/main/java/com/example/demo路径打开已生成的DemoApplication.java文件，并将下面这段代码直接贴上去：
package com.example.demo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @SpringBootApplication @RestController public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } @GetMapping(&#34;/hello&#34;) public String hello(@RequestParam(value = &#34;name&#34;, defaultValue = &#34;World&#34;) String name) { return String.format(&#34;Hello %s!&#34;, name); } } 在代码中，自定义的hello()函数表示其中被定义的内容会以字符串的形式被投射在web上。 以@符号开头的我们将其称为注释，它会告诉Spring框架这里面隐含了一大段代码，他们也分别有各自的作用：
 @RestController：表示接下来的代码的内容将会被投放到web上。 @GetMapping(&quot;/hello&quot;)：将我们定义的hello()函数发送到我们之后将访问的端口的页面上。 @RequestParam：将Sting的值设为name，默认值为World。  最后通过main函数执行程序之后我们可以访问本机中的http://localhost:8080/hello地址，便可以看到我们预期之中的结果了！" />
  <meta name="author" content="" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://ggshihaoren.github.io/app.min.css" />

  
  <link rel="preload stylesheet" as="style" href="https://ggshihaoren.github.io/an-old-hope.min.css" />
  <script
    defer
    src="https://ggshihaoren.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  <link rel="preload" as="image" href="https://ggshihaoren.github.io/theme.png" />

  

  
  <link rel="icon" href="https://ggshihaoren.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://ggshihaoren.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.97.2" />

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="初学SpringBoot" />
<meta property="og:description" content="从后端零基础开始 由于本学期J2EE课程作业需要，我们小组需要前后端分离去学习不同的东西。前端关于HTML,CSS,JSP的内容已经有些许了解了，但是后端部分的知识却是一点都不知道。出于想学习新东西的心态，我便选择开始学习后端部分的知识。
可能是觉得老师教的东西有些许过时了，我们的组长便决定不完全按照老师所教的东西来，而是选择了SpringBoot 和 MyBatis 作为我们的后端选型，数据库也不是MYSQL，而是 MariaDB(我们组长到底是怎么知道这么多东西的真的好厉害必须狠狠夸一波)。
于是便有了后面一些关于SpringBoot的简单学习。
SpringBoot是什么？ 要弄懂SpringBoot是什么或许得先了解Spring应用开发的相关知识。简单来说，它是一种为了解决企业应用程序开发复杂性而创建的开源的框架。框架的主要优势之一就是其分层架构，分层架构允许我们使用哪一种组件，同时为J2EE应用程序开发提供了集成的框架。
而SpringBoot呢？它也是一种框架。它被设计出来的目的便是为了简化Spring应用的创建，运行，调试，部署等功能。它打包了许多本来需要我们自己去配置的功能，按照人们的使用习惯解决了依赖问题，这样便可以降低开发人员对于框架的关注点，可以把更多的精力放在自己的业务代码上。总的来说，其目的就是为了Java Web的开发进行&quot;简化&quot;和&quot;加快速度&quot;，简化开发过程中引入或启动相关Spring功能的配置。使用SpringBoot我们就可以不用或者只需很少的Spring配置就可以让企业项快速运行起来。
简单尝试 打开IDEA，Generator选择的是Spring Initializr，取名默认为demo，再选择了Gradle作为此次的项目结构便开始了我的第一次尝试(网上大部分的教程好像都是使用了MAVEN，但是据说是使用Gradle的人越来越多了，便试着使用了它)。这里要注意在第二步中需要勾选Spring Web才能顺利进行这个框架的构建~
之后便是愉快的贴代码环节了。通过src/main/java/com/example/demo路径打开已生成的DemoApplication.java文件，并将下面这段代码直接贴上去：
package com.example.demo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @SpringBootApplication @RestController public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } @GetMapping(&#34;/hello&#34;) public String hello(@RequestParam(value = &#34;name&#34;, defaultValue = &#34;World&#34;) String name) { return String.format(&#34;Hello %s!&#34;, name); } } 在代码中，自定义的hello()函数表示其中被定义的内容会以字符串的形式被投射在web上。 以@符号开头的我们将其称为注释，它会告诉Spring框架这里面隐含了一大段代码，他们也分别有各自的作用：
 @RestController：表示接下来的代码的内容将会被投放到web上。 @GetMapping(&quot;/hello&quot;)：将我们定义的hello()函数发送到我们之后将访问的端口的页面上。 @RequestParam：将Sting的值设为name，默认值为World。  最后通过main函数执行程序之后我们可以访问本机中的http://localhost:8080/hello地址，便可以看到我们预期之中的结果了！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ggshihaoren.github.io/posts/%E5%88%9D%E5%AD%A6springboot/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-05T14:51:48+08:00" />
<meta property="article:modified_time" content="2022-05-05T14:51:48+08:00" />


  
  <meta itemprop="name" content="初学SpringBoot">
<meta itemprop="description" content="从后端零基础开始 由于本学期J2EE课程作业需要，我们小组需要前后端分离去学习不同的东西。前端关于HTML,CSS,JSP的内容已经有些许了解了，但是后端部分的知识却是一点都不知道。出于想学习新东西的心态，我便选择开始学习后端部分的知识。
可能是觉得老师教的东西有些许过时了，我们的组长便决定不完全按照老师所教的东西来，而是选择了SpringBoot 和 MyBatis 作为我们的后端选型，数据库也不是MYSQL，而是 MariaDB(我们组长到底是怎么知道这么多东西的真的好厉害必须狠狠夸一波)。
于是便有了后面一些关于SpringBoot的简单学习。
SpringBoot是什么？ 要弄懂SpringBoot是什么或许得先了解Spring应用开发的相关知识。简单来说，它是一种为了解决企业应用程序开发复杂性而创建的开源的框架。框架的主要优势之一就是其分层架构，分层架构允许我们使用哪一种组件，同时为J2EE应用程序开发提供了集成的框架。
而SpringBoot呢？它也是一种框架。它被设计出来的目的便是为了简化Spring应用的创建，运行，调试，部署等功能。它打包了许多本来需要我们自己去配置的功能，按照人们的使用习惯解决了依赖问题，这样便可以降低开发人员对于框架的关注点，可以把更多的精力放在自己的业务代码上。总的来说，其目的就是为了Java Web的开发进行&quot;简化&quot;和&quot;加快速度&quot;，简化开发过程中引入或启动相关Spring功能的配置。使用SpringBoot我们就可以不用或者只需很少的Spring配置就可以让企业项快速运行起来。
简单尝试 打开IDEA，Generator选择的是Spring Initializr，取名默认为demo，再选择了Gradle作为此次的项目结构便开始了我的第一次尝试(网上大部分的教程好像都是使用了MAVEN，但是据说是使用Gradle的人越来越多了，便试着使用了它)。这里要注意在第二步中需要勾选Spring Web才能顺利进行这个框架的构建~
之后便是愉快的贴代码环节了。通过src/main/java/com/example/demo路径打开已生成的DemoApplication.java文件，并将下面这段代码直接贴上去：
package com.example.demo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @SpringBootApplication @RestController public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } @GetMapping(&#34;/hello&#34;) public String hello(@RequestParam(value = &#34;name&#34;, defaultValue = &#34;World&#34;) String name) { return String.format(&#34;Hello %s!&#34;, name); } } 在代码中，自定义的hello()函数表示其中被定义的内容会以字符串的形式被投射在web上。 以@符号开头的我们将其称为注释，它会告诉Spring框架这里面隐含了一大段代码，他们也分别有各自的作用：
 @RestController：表示接下来的代码的内容将会被投放到web上。 @GetMapping(&quot;/hello&quot;)：将我们定义的hello()函数发送到我们之后将访问的端口的页面上。 @RequestParam：将Sting的值设为name，默认值为World。  最后通过main函数执行程序之后我们可以访问本机中的http://localhost:8080/hello地址，便可以看到我们预期之中的结果了！"><meta itemprop="datePublished" content="2022-05-05T14:51:48+08:00" />
<meta itemprop="dateModified" content="2022-05-05T14:51:48+08:00" />
<meta itemprop="wordCount" content="191">
<meta itemprop="keywords" content="SpringBoot,Spring,JSON,HTTP," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="初学SpringBoot"/>
<meta name="twitter:description" content="从后端零基础开始 由于本学期J2EE课程作业需要，我们小组需要前后端分离去学习不同的东西。前端关于HTML,CSS,JSP的内容已经有些许了解了，但是后端部分的知识却是一点都不知道。出于想学习新东西的心态，我便选择开始学习后端部分的知识。
可能是觉得老师教的东西有些许过时了，我们的组长便决定不完全按照老师所教的东西来，而是选择了SpringBoot 和 MyBatis 作为我们的后端选型，数据库也不是MYSQL，而是 MariaDB(我们组长到底是怎么知道这么多东西的真的好厉害必须狠狠夸一波)。
于是便有了后面一些关于SpringBoot的简单学习。
SpringBoot是什么？ 要弄懂SpringBoot是什么或许得先了解Spring应用开发的相关知识。简单来说，它是一种为了解决企业应用程序开发复杂性而创建的开源的框架。框架的主要优势之一就是其分层架构，分层架构允许我们使用哪一种组件，同时为J2EE应用程序开发提供了集成的框架。
而SpringBoot呢？它也是一种框架。它被设计出来的目的便是为了简化Spring应用的创建，运行，调试，部署等功能。它打包了许多本来需要我们自己去配置的功能，按照人们的使用习惯解决了依赖问题，这样便可以降低开发人员对于框架的关注点，可以把更多的精力放在自己的业务代码上。总的来说，其目的就是为了Java Web的开发进行&quot;简化&quot;和&quot;加快速度&quot;，简化开发过程中引入或启动相关Spring功能的配置。使用SpringBoot我们就可以不用或者只需很少的Spring配置就可以让企业项快速运行起来。
简单尝试 打开IDEA，Generator选择的是Spring Initializr，取名默认为demo，再选择了Gradle作为此次的项目结构便开始了我的第一次尝试(网上大部分的教程好像都是使用了MAVEN，但是据说是使用Gradle的人越来越多了，便试着使用了它)。这里要注意在第二步中需要勾选Spring Web才能顺利进行这个框架的构建~
之后便是愉快的贴代码环节了。通过src/main/java/com/example/demo路径打开已生成的DemoApplication.java文件，并将下面这段代码直接贴上去：
package com.example.demo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @SpringBootApplication @RestController public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } @GetMapping(&#34;/hello&#34;) public String hello(@RequestParam(value = &#34;name&#34;, defaultValue = &#34;World&#34;) String name) { return String.format(&#34;Hello %s!&#34;, name); } } 在代码中，自定义的hello()函数表示其中被定义的内容会以字符串的形式被投射在web上。 以@符号开头的我们将其称为注释，它会告诉Spring框架这里面隐含了一大段代码，他们也分别有各自的作用：
 @RestController：表示接下来的代码的内容将会被投放到web上。 @GetMapping(&quot;/hello&quot;)：将我们定义的hello()函数发送到我们之后将访问的端口的页面上。 @RequestParam：将Sting的值设为name，默认值为World。  最后通过main函数执行程序之后我们可以访问本机中的http://localhost:8080/hello地址，便可以看到我们预期之中的结果了！"/>

  
  
</head>


  <body class="not-ready" data-menu="false">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://ggshihaoren.github.io/">GG&#39;s blog</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  

  
</header>


    <main class="main">

<article class="post-single">
  <header class="post-title">
    <p>
      
      <time>May 5, 2022</time>
      
      
    </p>
    <h1>初学SpringBoot</h1>
  </header>
  <section class="post-content"><h2 id="从后端零基础开始">从后端零基础开始</h2>
<p>由于本学期J2EE课程作业需要，我们小组需要前后端分离去学习不同的东西。前端关于<code>HTML</code>,<code>CSS</code>,<code>JSP</code>的内容已经有些许了解了，但是后端部分的知识却是一点都不知道。出于想学习新东西的心态，我便选择开始学习后端部分的知识。</p>
<p>可能是觉得老师教的东西有些许过时了，我们的组长便决定不完全按照老师所教的东西来，而是选择了<code>SpringBoot</code> 和 <code>MyBatis</code> 作为我们的后端选型，数据库也不是<code>MYSQL</code>，而是 <code>MariaDB</code>(我们组长到底是怎么知道这么多东西的真的好厉害必须狠狠夸一波)。</p>
<p>于是便有了后面一些关于SpringBoot的简单学习。</p>
<h2 id="springboothttpsspringio是什么"><a href="https://spring.io/">SpringBoot</a>是什么？</h2>
<p>要弄懂SpringBoot是什么或许得先了解Spring应用开发的相关知识。简单来说，它是一种为了解决企业应用程序开发复杂性而创建的开源的框架。框架的主要优势之一就是其分层架构，分层架构允许我们使用哪一种组件，同时为J2EE应用程序开发提供了集成的框架。</p>
<p>而SpringBoot呢？它也是一种框架。它被设计出来的目的便是<strong>为了简化Spring应用的创建，运行，调试，部署等功能</strong>。它打包了许多本来需要我们自己去配置的功能，按照人们的使用习惯解决了依赖问题，这样便可以降低开发人员对于框架的关注点，可以把更多的精力放在自己的业务代码上。总的来说，其目的就是为了Java Web的开发进行&quot;简化&quot;和&quot;加快速度&quot;，简化开发过程中引入或启动相关Spring功能的配置。使用SpringBoot我们就可以不用或者只需很少的Spring配置就可以让企业项快速运行起来。</p>
<h2 id="简单尝试">简单尝试</h2>
<p>打开IDEA，Generator选择的是Spring Initializr，取名默认为demo，再选择了<code>Gradle</code>作为此次的项目结构便开始了我的第一次尝试(网上大部分的教程好像都是使用了MAVEN，但是据说是使用Gradle的人越来越多了，便试着使用了它)。这里要注意在第二步中需要勾选Spring Web才能顺利进行这个框架的构建~</p>
<p>之后便是愉快的贴代码环节了。通过<code>src/main/java/com/example/demo</code>路径打开已生成的<code>DemoApplication.java</code>文件，并将下面这段代码直接贴上去：</p>
<pre tabindex="0"><code>package com.example.demo;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
              
@SpringBootApplication
@RestController
public class DemoApplication {
                               
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
                  
    @GetMapping(&#34;/hello&#34;)
    public String hello(@RequestParam(value = &#34;name&#34;, defaultValue = &#34;World&#34;) String name) {
        return String.format(&#34;Hello %s!&#34;, name);
    }
                
}          
</code></pre><p>在代码中，自定义的<code>hello()</code>函数表示其中被定义的内容会以字符串的形式被投射在web上。 以<code>@</code>符号开头的我们将其称为注释，它会告诉Spring框架这里面隐含了一大段代码，他们也分别有各自的作用：</p>
<ul>
<li><code>@RestController</code>：表示接下来的代码的内容将会被投放到web上。</li>
<li><code>@GetMapping(&quot;/hello&quot;)</code>：将我们定义的<code>hello()</code>函数发送到我们之后将访问的端口的页面上。</li>
<li><code>@RequestParam</code>：将Sting的值设为<code>name</code>，默认值为<code>World</code>。</li>
</ul>
<p>最后通过main函数执行程序之后我们可以访问本机中的<code>http://localhost:8080/hello</code>地址，便可以看到我们预期之中的结果了！</p>
<p>当然，前面我们也说了这里的name只是个默认值，所以我们如果要进行修改的话，可以在地址后面增加?name=GuanGuan，这样就会得到另外你想要的结果了。</p>
<h2 id="进阶">进阶</h2>
<p>接下来试试创建一个RESTful Web Service。<br>
这里先将访问端口摆出来：<code>http://localhost:8080/greeting</code>.<br>
展示出以下的JSON格式是我们的最终目的。</p>
<pre tabindex="0"><code>{&#34;id&#34;:1,&#34;content&#34;:&#34;Hello, World!&#34;}
</code></pre><p>因为我们需要获得这种格式，所以我们需要创建一个可以表示这种资源格式的实体类而去建立它的模型。首先，我们需要<code>id</code>（greeting的次数）和<code>content</code>（greeting的文本方式）这两个数据，其次，我们还需要构造函数，以及获取他们的值的方式。该类的定义如下，我将其命名为Greeting后存在了<code>src/main/java/com/example/restservice/Greeting.java</code>路径下。这个实体类可以被序列化成我们想要的JSON格式。</p>
<pre tabindex="0"><code>package com.example.restservice;

public class Greeting {

	private final long id;
	private final String content;

	public Greeting(long id, String content) {
		this.id = id;
		this.content = content;
	}

	public long getId() {
		return id;
	}

	public String getContent() {
		return content;
	}
}
</code></pre><p>由于在 Spring 构建 RESTful web 服务的方法中，HTTP的请求通常由控制器处理，因此我们还需要创建一个控制器。它和我们之前编写的hello()其实十分相像：</p>
<pre tabindex="0"><code>package com.example.restservice;

import java.util.concurrent.atomic.AtomicLong;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class GreetingController {

	private static final String template = &#34;Hello, %s!&#34;;
	private final AtomicLong counter = new AtomicLong();

	@GetMapping(&#34;/greeting&#34;)
	public Greeting greeting(@RequestParam(value = &#34;name&#34;, defaultValue = &#34;World&#34;) String name) {
		return new Greeting(counter.incrementAndGet(), String.format(template, name));
	}
}
</code></pre><p>代码中以<code>@</code>开头的注释和之前的意思是一样的。这段代码和之前的区别只有两个，一个我们使用了<code>AtomicLong</code>类定义了一个<code>counter</code>，而用它去记录我们的<code>id</code>的数值，除此之外，<code>greeting()</code>函数返回的是我们自己创造的<code>Greeting</code>类型。</p>
<h3 id="好处">好处</h3>
<p>它和传统MVC的区别在于 <strong>创建HTTP响应体的方式</strong></p>
<ul>
<li>RESTful Web服务控制器填充并返回一个Greeting对象，并将对象数据作为JSON直接写入HTTP相应</li>
<li>传统MVC依赖于试图转换，组装成HTML的服务器端呈现</li>
<li>RESTful Web服务的每个方法均返回<code>领域对象</code>而不是<code>视图</code>。</li>
</ul>
<p>最后依旧是通过访问<code>http://localhost:8080/greeting</code>得到被返回的JSON字符串结果。至于为什么通过创建这个实体类就可以得到JSON的格式，是因为由于Spring的HTTP消息转换器，我们无需手动进行这个操作去进行转换。因为Jackson 2位于类路径上，所以会自动选择Spring的<code>MappingJackson2HttpMessageConvert</code>将<code>Greeting</code>转化为JSON。</p>
<h3 id="拓展build-an-executable-jar">拓展（Build an executable JAR）</h3>
<p>SpringBoot有很棒的一点就是我们可以通过将其打包成一个<code>jar</code>文件而后直接运行，这样便可以变得十分简洁，且方便我们使用。它需要包含所有的依赖项，类和资源。而这样生产的可执行的jar可以轻松地将一个服务器作为应用程序进行发布，版本化和部署。</p>
</section>

  
  
  <footer class="post-tags">
     
    <a href="https://ggshihaoren.github.io/tags/springboot">SpringBoot</a>
     
    <a href="https://ggshihaoren.github.io/tags/spring">Spring</a>
     
    <a href="https://ggshihaoren.github.io/tags/json">JSON</a>
     
    <a href="https://ggshihaoren.github.io/tags/http">HTTP</a>
    
  </footer>
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://ggshihaoren.github.io/posts/helloworld/"><span>←</span><span>Hello World!</span></a>
     
  </nav>
  

  
  
</article>

</main>

    <footer class="footer">
  <p>&copy; 2022 <a href="https://ggshihaoren.github.io/">GG&#39;s blog</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.1</a>
  </p>
</footer>

  </body>
</html>
